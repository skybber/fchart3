#!/usr/bin/python

#    fchart draws beautiful deepsky charts in vector formats
#    fchart3 CLI enhancements: horizontal coordinate input parsing
#    Copyright (C) 2005-2025 fchart authors
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""
Generate a multi-page full-sky atlas by calling fchart3 repeatedly.
- Default tiling is equatorial (RA/Dec) like TriAtlas.
- Produces one PDF (or SVG/PNG) per tile; optionally merges them into one PDF.

Notes:
- fchart3 CLI accepts "RA,Dec,Caption" as a source position (RA in hours, Dec in degrees).
- We call fchart3 once per tile to keep filenames unique and predictable.
"""

import argparse
import math
import shutil
import subprocess
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple


@dataclass(frozen=True)
class Tile:
    ra_hours: float   # 0..24
    dec_deg: float    # -90..+90
    name: str         # caption + filename stem


def wrap_ra_hours(h: float) -> float:
    """Wrap RA hours into [0, 24)."""
    h = h % 24.0
    if h < 0:
        h += 24.0
    return h


def h2hms(h: float) -> str:
    """Format RA hours as sexagesimal 'HH:MM:SS.s' string for fchart3."""
    h = wrap_ra_hours(h)
    hh = int(h)
    mm_f = (h - hh) * 60.0
    mm = int(mm_f)
    ss = (mm_f - mm) * 60.0
    return f"{hh:02d}:{mm:02d}:{ss:04.1f}"


def d2dms(d: float) -> str:
    """Format degrees as sexagesimal '±DD:MM:SS.s'."""
    sign = "+" if d >= 0 else "-"
    d = abs(d)
    dd = int(d)
    mm_f = (d - dd) * 60.0
    mm = int(mm_f)
    ss = (mm_f - mm) * 60.0
    return f"{sign}{dd:02d}:{mm:02d}:{ss:04.1f}"


def build_equatorial_tiles(field_deg: float, overlap: float) -> List[Tile]:
    """
    Build an approximate full-sky tiling using declination bands.

    Fix: RA spacing must be computed using spherical geometry for larger fields,
    otherwise gaps can appear (small-angle approximation breaks for big FOV).

    We keep Dec spacing as:
      step_dec = field_deg * (1 - overlap)
    (this is exact along a meridian).

    For RA spacing at a given declination, we compute the actual RA half-width Δα
    of a spherical circle with angular radius r = field_deg/2:
      cos(r) = sin^2(dec) + cos^2(dec)*cos(Δα)
      Δα = arccos((cos(r) - sin^2(dec)) / cos^2(dec))

    Then full RA width at that declination is:
      width_ra_deg = 2 * degrees(Δα)
    And we apply overlap the same way as in Dec:
      step_ra_deg = width_ra_deg * (1 - overlap)
    """
    if not (0.0 <= overlap < 1.0):
        raise ValueError("overlap must be in [0, 1).")

    step_dec = field_deg * (1.0 - overlap)
    if step_dec <= 0:
        raise ValueError("field_deg*(1-overlap) must be > 0.")

    r_rad = math.radians(field_deg / 2.0)

    # Keep tile centers inside valid range so the circular FOV stays within [-90, +90] in declination.
    dec_min = -90.0 + field_deg / 2.0
    dec_max = +90.0 - field_deg / 2.0

    tiles: List[Tile] = []
    dec = dec_min
    band_idx = 0

    while dec <= dec_max + 1e-9:
        dec_rad = math.radians(dec)
        sin_dec = math.sin(dec_rad)
        cos_dec = math.cos(dec_rad)

        # Near the poles, one tile per band is enough (and avoids numeric issues).
        if abs(cos_dec) < 1e-6:
            n_ra = 1
        else:
            # Compute RA half-width Δα for the circle at this declination.
            # Clamp argument to [-1, 1] to avoid acos domain errors due to floating point.
            cos_r = math.cos(r_rad)
            denom = (cos_dec * cos_dec)
            arg = (cos_r - (sin_dec * sin_dec)) / denom
            arg = max(-1.0, min(1.0, arg))

            delta_alpha_rad = math.acos(arg)
            width_ra_deg = 2.0 * math.degrees(delta_alpha_rad)

            # Apply overlap consistently (same logic as Dec).
            step_ra_deg = width_ra_deg * (1.0 - overlap)

            # Convert RA step from degrees to hours (15 deg = 1 hour).
            step_ra_h = step_ra_deg / 15.0

            # Ensure we cover full 24h without gaps.
            # We round to an integer number of tiles and then distribute evenly.
            n_ra = max(1, int(math.ceil(24.0 / step_ra_h)))

        step_ra_h = 24.0 / n_ra

        for i in range(n_ra):
            ra = i * step_ra_h
            name = f"tile_{band_idx:02d}_{i:03d}_RA{h2hms(ra).replace(':','')}_DEC{d2dms(dec).replace(':','')}"
            tiles.append(Tile(ra_hours=ra, dec_deg=dec, name=name))

        band_idx += 1
        dec += step_dec

    return tiles


def run_fchart3_for_tile(
        fchart3_bin: str,
        out_dir: Path,
        tile: Tile,
        *,
        config_file: str | None,
        width_mm: float,
        height_mm: float,
        field_deg: float,
        projection: str,
        language: str,
        limit_star: float | None,
        limit_dso: float | None,
        extra_args: List[str],
        output_ext: str,
) -> None:
    """
    Call fchart3 once for a single tile.
    We do NOT pass -f/--output-file because that would override all outputs.
    Instead we use the caption as filename stem (your CLI does that for position sources).
    """
    out_dir.mkdir(parents=True, exist_ok=True)

    # Build the position source string (RA hours, Dec degrees, Caption).
    source = f"{h2hms(tile.ra_hours)},{d2dms(tile.dec_deg)},{tile.name}"

    cmd = [
        fchart3_bin,
        "-o", str(out_dir),
        "-W", str(width_mm),
        "-H", str(height_mm),
        "-fov", str(field_deg),
        "--projection", projection,
        "-l", language,
        # Typical atlas defaults (optional; comment out if you want):
        # "--show-coords-legend",
        # "--show-map-orientation-legend",
        # "--show-equatorial-grid",
        # "--hide-star-labels",
    ]

    if config_file:
        cmd += ["-c", config_file]
    if limit_star is not None:
        cmd += ["-ls", str(limit_star)]
    if limit_dso is not None:
        cmd += ["-ld", str(limit_dso)]

    # You can pass extra raw CLI args (e.g. ["--show-equatorial-grid"]).
    cmd += extra_args

    # Enforce desired format by letting fchart3 append .pdf by default.
    # If you want svg/png, you can pass "--output-file" per call, but we rely on stem naming.
    # So we post-rename if needed OR simply keep PDF and convert externally.
    #
    # Your CLI chooses format by filename extension; for position sources it does `filename += '.pdf'`.
    # Therefore: easiest is to generate PDF always, and optionally convert later.
    if output_ext.lower() not in ("pdf",):
        # Keep it simple: generate PDF, then external convert step (not implemented here).
        pass

    cmd.append(source)

    subprocess.run(cmd, check=True)


def merge_pdfs(out_dir: Path, merged_name: str) -> None:
    """
    Merge PDF pages into one file using a best-effort external tool:
    - pdfunite (poppler-utils) OR
    - qpdf
    - gs (Ghostscript)

    If none exists, we just leave separate PDFs.
    """
    pdfs = sorted(out_dir.glob("*.pdf"))
    if not pdfs:
        return

    target = out_dir / merged_name

    # Try pdfunite
    pdfunite = shutil.which("pdfunite")
    if pdfunite:
        subprocess.run([pdfunite, *map(str, pdfs), str(target)], check=True)
        return

    # Try qpdf
    qpdf = shutil.which("qpdf")
    if qpdf:
        subprocess.run([qpdf, "--empty", "--pages", *map(str, pdfs), "--", str(target)], check=True)
        return

    # Try Ghostscript
    gs = shutil.which("gs")
    if gs:
        subprocess.run(
            [
                gs, "-dBATCH", "-dNOPAUSE", "-q",
                "-sDEVICE=pdfwrite",
                f"-sOutputFile={target}",
                *map(str, pdfs),
            ],
            check=True,
        )
        return

    print("No PDF merge tool found (pdfunite/qpdf/gs). Leaving individual PDFs.")


def main() -> None:
    ap = argparse.ArgumentParser(description="Generate a multi-page full-sky atlas via fchart3.")
    ap.add_argument("--fchart3", default="fchart3", help="Path to fchart3 executable.")
    ap.add_argument("--out", default="./atlas_out", help="Output directory.")
    ap.add_argument("--config", default=None, help="fchart3 config file name or path (passed to -c).")

    ap.add_argument("--width-mm", type=float, default=180.0, help="Page width in mm.")
    ap.add_argument("--height-mm", type=float, default=270.0, help="Page height in mm.")
    ap.add_argument("--field-deg", type=float, default=45.0, help="Field of view diameter in degrees.")
    ap.add_argument("--overlap", type=float, default=0.20, help="Tile overlap fraction (0..1).")

    ap.add_argument("--projection", default="stereographic", choices=["stereographic", "orthographic", "equidistant"])
    ap.add_argument("--language", default="en", help="Map language (passed to -l).")

    ap.add_argument("--limit-star", type=float, default=9, help="Limiting magnitude for stars (-ls).")
    ap.add_argument("--limit-dso", type=float, default=9, help="Limiting magnitude for DSO (-ld).")

    ap.add_argument("--merge", action="store_true", help="Merge produced PDFs into one atlas.pdf (requires pdfunite/qpdf/gs).")
    ap.add_argument("--merged-name", default="atlas.pdf", help="Merged PDF filename.")
    ap.add_argument("--extra-arg", action="append", default=[], help="Extra fchart3 CLI arg (repeatable). Example: --extra-arg --show-equatorial-grid")
    args = ap.parse_args()

    out_dir = Path(args.out).expanduser().resolve()

    # Build tiles
    tiles = build_equatorial_tiles(args.field_deg, args.overlap)
    print(f"Tiles: {len(tiles)}")

    # Generate pages
    for idx, t in enumerate(tiles, start=1):
        print(f"[{idx}/{len(tiles)}] {t.name}  RA={h2hms(t.ra_hours)}  Dec={d2dms(t.dec_deg)}")
        run_fchart3_for_tile(
            args.fchart3,
            out_dir,
            t,
            config_file=args.config,
            width_mm=args.width_mm,
            height_mm=args.height_mm,
            field_deg=args.field_deg,
            projection=args.projection,
            language=args.language,
            limit_star=args.limit_star,
            limit_dso=args.limit_dso,
            extra_args=args.extra_arg,
            output_ext="pdf",
        )

    # Optional merge
    if args.merge:
        merge_pdfs(out_dir, args.merged_name)
        print(f"Merged: {out_dir / args.merged_name}")


if __name__ == "__main__":
    main()
